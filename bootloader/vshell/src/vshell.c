/**
*******************************************************************************************************
*			 			 					shell命令解析								 
*                      		(c) Copyright 2013-2020, xxx公司, 广州
*                              			All Rights Reserved
*  
* 
* @文件名	vshell.c
* @作者  		 
* @版本 	V1.1
* @日期    	2017-09-06
* @说明   	该文件实现命令的解析及运行。
*******************************************************************************************************
* @相关说明
* 20170925
* --------
* 1、键盘方位键：1B 5B + [上41]/[下42]/[左44]/[右43]  
*
*******************************************************************************************************
* @修改记录
* 20170925
* ---------
* 1、接收缓存相关变量改为结构体变量。
*******************************************************************************************************
*/

/* Includes ------------------------------------------------------------------------------------------*/
#include "stm32f10x.h"
#include "vshell.h"
#include "vshell_list.h"
#include "vshell_io.h"
#include "bsp.h"
#include "iap.h"
#include "stdio.h"
#include "string.h"



/* Private functions --------------------------------------------------------------------------------*/
static int vshell_parse(char *buf, char *argv[]);
static int vshell_run(int argc, char * argv[]);
static char abortboot(int bootdelay);

/* Private variables ---------------------------------------------------------------------------------*/
cmd_tbl_t *cmd_tbl_p = NULL; 							/*	声明一个cmd_tbl_t的结构体指针			  */
SHELL_TCB recieve_tcb = {0};





/*
*********************************************************************************************************
*                                        shell命令解析接口
*
* 描述  : 通过串口接收到相应的字符串，对字符串进行解析判断。
*
* 参数  : buf		字符串缓存地址
*		  argv		解析后的字符串缓存地址	
*
* 返回值: 字符串个数
*
* 备注  : 无	
*********************************************************************************************************
*/
static int vshell_parse(char *buf, char *argv[])
{
	int argc = 1;																											      
	int state = 0;

	/* 逐个读出字符																					   */
	while(*buf)
	{
		/* 从第一个不为空的字符开始判断，认为一个单词												   */
		if(*buf != ' ' && state == 0)
		{
			argv[argc++] = buf;	  				/*	将该单词的首地址存放在argv中					   */
			state = 1;						    /*	标记识别一个单词								   */
		}
		/* 跳过空格																					   */
		if(*buf == ' ' && state == 1)	  		/*	遇到空时，则认为是一个完整的单词				   */
		{
			*buf = '\0';					   	/*	添加‘\0’表示是一个完整的单词					   */
			state = 0;							/*  标记开始识别下一个单词							   */
		}
		buf++;									/*  指向下一个字符									   */
	}
	argc--;
	argv[0] = (char *)(argc-1);	  				/*  将字符串个数保存在argv[0]中						   */
	return argc;								/*	返回字符串个数									   */
}





/*
*********************************************************************************************************
*                                        shell运行正确解析的命令
*
* 描述  : 运行正确解析的命令。
*
* 参数  : argc		字符串个数
*		  argv		解析后的字符串缓存地址	
*
* 返回值: 0			解析成功
*         1   		解析失败
*
* 备注  : 无	
*********************************************************************************************************
*/
static int vshell_run(int argc, char * argv[])
{											   	
 	cmd_tbl_p = (cmd_tbl_t *)cmd_tbl_c;			/* 获取命令链表表头											*/
								  
	while(cmd_tbl_p->cmd != 0 && strcasecmp(cmd_tbl_p->name, argv[1]) !=0) /* 解析命令，与命令链表进行匹配	*/
		cmd_tbl_p ++;							/* 不匹配则继续匹配命令表中的下一个成员						*/

	if(cmd_tbl_p->cmd != 0)						/* 判断是否匹配成功*/
	{
 		(*cmd_tbl_p->cmd) ( cmd_tbl_p, 
							cmd_tbl_p->maxargs, 
							cmd_tbl_p->repeatable, 
							argv);				/* 匹配成功，执行相应的操作									*/
		return 0;
	}
	else
		printf("\r\n\tInvalid command!\n\r");	/* 失败，输出提示信息						 				*/		

	return 1;
}





/*
*********************************************************************************************************
*                                        	中止启动
*
* 描述  : 根据设定的开机延迟值以及是否按键输入判断是否要中止启动。
*
* 参数  : bootdelay	
*
* 返回值: 0			正常运行
*         1   		中止启动
*
* 备注  : 无	
*********************************************************************************************************
*/
static char abortboot(int bootdelay)
{
	int abort = 0;
	int i;
	printf("Hit any key to stop autoboot: %2d ", bootdelay);
	while((bootdelay > 0) && (!abort))
	{
		
		--bootdelay;
		for(i = 0; !abort && i < 100; i++)
		{
		  	if(tstc())
			{
				abort = 1;
				bootdelay = 0;
				break;
			}
		}
		printf("\b\b\b%2d ", bootdelay);
	}
	return abort;						/*	return abort: 1 - press, 0 - timeout 						*/
}



/*
*********************************************************************************************************
*                                        	shell命令行主入口
*
* 描述  : 该函数内部可在设定的时间CONFIG_BOOTDELAY内判断是否有按键输入，若有则进入命令行，否则直接启动
*		  固件程序。
*
* 参数  : 无
*
* 返回值: 无
*
* 备注  : 无	
*********************************************************************************************************
*/
void main_loop(void)
{
	int bootdelay;
	
#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	bootdelay = CONFIG_BOOTDELAY;
	if(bootdelay >= 0 && !abortboot(bootdelay))
	{
	 	IAP_Load(0x08009000);
	} 

	parse_file_outer();
	for(;;);
#else
	
#endif

}
/*
*********************************************************************************************************
*                                        	shell命令行入口
*
* 描述  : 用户调用该函数即可运行完整的shell。
*
* 参数  : 无	
*
* 返回值: 无
*
* 备注  : 无	
*********************************************************************************************************
*/
void parse_file_outer(void)
{
	printf("\n\r###      vshell  V1.1 2017-05-25   ###\r\n");
	printf("\n\r###      Use for STM32F103xx       ###\r\n");
	while(1)
	{
		printf("\n\r[shell@STM32]# "); 						/* 命令行提示								*/
		vshell_gets(recieve_tcb.buf);						/* 等待输入字符信息							*/
	  	recieve_tcb.argc = vshell_parse(recieve_tcb.buf,
										recieve_tcb.argv);	/* 输入完毕，解析字符信息					*/
		if(recieve_tcb.argc != 0)							/* 输入信息不为空，则进行命令解析			*/
			vshell_run(recieve_tcb.argc, recieve_tcb.argv);
	}
}





 

